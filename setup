#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'


export DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
export DEFAULT_DATA_DIR="/tmp/geth"
export DATA_DIRECTORY=${DATA_DIRECTORY:="$DEFAULT_DATA_DIR"}
export NETWORK=${NETWORK:="geth"}
export CONFIG_FILE=${CONFIG_FILE:=$PWD/".env.$NETWORK"}

#TODO: expect for GETH_DOCKER_IMAGE
# if we are running geth in docker (for testnets)
# then which folder do we mount the data folder to?
export GETH_DATA_DIRECTORY=${GETH_DATA_DIRECTORY:="/var/lib/hive/geth"}
# which docker network do we connect geth to?
export GETH_DOCKER_NETWORK=${GETH_DOCKER_NETWORK:="coophive"}
# what is the docker image that we use for geth?
export GETH_DOCKER_IMAGE=${GETH_DOCKER_IMAGE:="ethereum/client-go:v1.13.5"}
# what is the docker image that we use for the faucet?
export FAUCET_DOCKER_IMAGE=${FAUCET_DOCKER_IMAGE:="hive-faucet"}
# what is the docker image that we use for solc compiler?
export SOLC_DOCKER_IMAGE=${SOLC_DOCKER_IMAGE:="hive-solc"}


#for hardhat config file
export CONFIG=${CONFIG:=$CONFIG_FILE}

# hardhat
function _setupHardhat(){
  cd hardhat
  npm install -g pnpm
  echo "Installing dependencies using pnpm.."
  pnpm install
}

#hive setup
function setup(){
  make
}

function compile-contracts() {
  (
    set -euo pipefail
    cd hardhat
    npx hardhat compile
  )
  ./scripts/go-bindings docker
}

function deploy-contracts() {
  (
    set -euo pipefail
    cd hardhat
    npx hardhat deploy --network "$NETWORK"
  )
}

## hardhat utils

function derivePkey() {
  if [ ! -d "hardhat/node_modules" ]; then
    echo "Node modules not found."
    #exit 2
    _setupHardhat
  fi

  primaryKey="$1"
  node hardhat/scripts/derive-pkey.js $primaryKey
}

function pkey() {
  derivePkey "$@"
}
#alias pkey=derivePkey
alias pKey=derivePkey


# Deep Dive into hardhat


function hardhat-script() {
  (
    set -euo pipefail
    cd hardhat
    npx hardhat run --network $NETWORK "$@"
  )
}

function hardhat-npm() {
  (
    set -euo pipefail
    cd hardhat
    npm run "$@"
  )
}
# print the env settings for the various accounts and private keys
function print-env() {
  (cd hardhat && npm run print-env) | grep export
}

#issue: $'\r': command not found
#The error message you're encountering, $'\r': command not found, typically indicates that there's a carriage return character (\r) present in your script, which can cause issues on Unix-like systems.
#This often happens when a script is written or edited on a Windows system and then transferred to a Unix-like system without converting line endings properly.
function _fixDappForUnix(){
  echo "fixing $1 for unix"
  sudo apt-get install dos2unix
  dos2unix "$1"
}

function print-contract-env() {
  local dappFile="config/dApps/$NETWORK.env"
  _fixDappForUnix $dappFile >/dev/null 2>&1
  #hardhat-script scripts/print-contract-env.ts | grep export
  cat $dappFile | grep HIVE_
}

function print-local-dev-env() {
  print-contract-env
}

function fund-services-ether() {
  #TODO: replace with npx hardhat fund
  hardhat-script scripts/fund-services-ether.ts
}

function fund-services-tokens() {
  #TODO: replace with npx hardhat fund <etherVal> <hiveTokenVal>
  #hardhat-script scripts/fund-services-tokens.ts
#  cd hardhat
#  pnpm fund $NETWORK 0 10000
  hardhat-npm fund $NETWORK 0 1000
#  FIXME: some transactions are failing
  hardhat-npm fund $NETWORK 0 1000
}

function balances() {
  hardhat-script scripts/balances.ts
}

function run-cowsay-onchain() {
  hardhat-script scripts/run-cowsay-onchain.ts
}


#geth setup

# run a local geth node in dev mode mounted against a local data directory
function geth() {
  docker network ls | grep coophive || docker network create coophive
  docker run -d --restart always \
    --name geth \
    --network coophive \
    -p 8545:8545 \
    -p 8546:8546 \
    -v ${DATA_DIRECTORY}:/data/geth \
    ${GETH_DOCKER_IMAGE} \
      --datadir /data/geth \
      --dev \
      --ws \
      --ws.api web3,eth,net \
      --ws.addr 0.0.0.0 \
      --ws.port 8546 \
      --ws.origins '*' \
      --http \
      --http.api web3,eth,net \
      --http.addr 0.0.0.0 \
      --http.corsdomain '*' \
      --http.port 8545 \
      --http.vhosts '*'
}

function geth-command() {
  docker exec -i geth geth --exec "$@" attach /data/geth/geth.ipc
}
# move ALL the money apart from 1 eth to the given admin account
# this expects the .env file to already have been created
function fund-admin() {
  ADMIN_PRIVATE_KEY=${ADMIN_PRIVATE_KEY:-""}
  export ADMIN_ADDRESS=${ADMIN_ADDRESS:-$(pkey "$ADMIN_PRIVATE_KEY")}
  if [[ -z "$ADMIN_ADDRESS" ]]; then
    echo >&2 "ADMIN_ADDRESS must be set"
    exit 1
  fi
  geth-command "eth.sendTransaction({from: eth.coinbase, to: \"${ADMIN_ADDRESS}\", value: new web3.BigNumber(eth.getBalance(eth.coinbase)).minus(web3.toWei(1, \"ether\"))  })"
}

# faucet

# run the faucet container
function faucet() {
  eval "$(print-contract-env)"
  HIVE_TOKEN=${HIVE_TOKEN:-""}
  ADMIN_PRIVATE_KEY=${ADMIN_PRIVATE_KEY:-""}
  export WEB3_TOKEN_ADDRESS=$HIVE_TOKEN
  # Checking if WEB3_TOKEN_ADDRESS is empty
  if [ -z "$WEB3_TOKEN_ADDRESS" ]; then
      echo "WEB3_TOKEN_ADDRESS is empty. failed" >&2
      exit 2
  else
      echo "WEB3_TOKEN_ADDRESS is $WEB3_TOKEN_ADDRESS"
  fi
  local privateKey=$(echo -n "$ADMIN_PRIVATE_KEY" | sed 's/^0x//')
  local tokenAddress=$(echo -n "$WEB3_TOKEN_ADDRESS" | sed 's/^0x//')
  docker run -d \
    --name faucet \
    -p 8080:8080 \
    --network coophive \
    -e PORT=8080 \
    -e WEB3_PROVIDER=http://geth:8545 \
    -e PRIVATE_KEY=$privateKey \
    -e TOKEN_ADDRESS=$tokenAddress \
    ghcr.io/coophive/faucet:latest \
      --faucet.amount=100 \
      --faucet.tokenamount=100 \
      --faucet.minutes=1
}

# bacalhau [for rp]


function bacalhau-serve() {
  export BACALHAU_SERVE_IPFS_PATH=${BACALHAU_SERVE_IPFS_PATH:-/tmp/coophive/data/ipfs}

  bacalhau serve \
    --node-type compute,requester \
    --peer none \
    --private-internal-ipfs=false \
    --job-selection-accept-networked \
    --web-ui --web-ui-port 1080
}


# hive

function install() {
    export GOBIN=$(go env GOBIN || echo '/usr/local/bin')
    go install . #installs hive to GOBIN
}

function check_install(){
   if ! command -v hive &>/dev/null; then
        echo "Error: hive executable not found"
        echo "$0 install"
        install
    fi
}

#alias hive='hive "$@"' FIXME: it only works for internal

function version() {
    hive version
}

## hive services

function mediator(){
    hive mediator $@
}

function solver() {
    hive solver $@
}

function jc() {
    hive jc $@
}

function rp() {
    hive rp $@
}

function run() {
    hive run $@
}


## hive modules

function runsdxl() {
  # Check for the number of arguments provided
  if [ $# -lt 3 ]; then
    echo "Usage: $0 runsdxl <model> \"<prompt>\""
    echo "Eg: $0 runsdxl sdxl:v0.3.0 \"hiro is building hive\""
    exit 1
  fi

  local model="$1"
  shift  # Remove the first argument, so "$@" contains only the second one
  local prompt="$@"
  go run . run $model -i "Prompt=$prompt"
}


# test

function unit-tests() {
  (
    set -euo pipefail
    cd hardhat
    npx hardhat test --network hardhat
  )
}

# this assumes boot having been run already
function integration-tests() {
  (
    set -euo pipefail
    cd test
    go test -v -count 1 .
  )
}

# cleanup

function geth-stop() {
  docker rm -f geth 2> /dev/null || true
}

function clean() {
  docker rm -f $(docker ps -aq) || true
  sudo rm -rf ${DATA_DIRECTORY}
#  TODO: remove hive also
  clean-deploy
}

function clean-deploy() {
  rm -rf hardhat/artifacts
  rm -rf hardhat/cache
  rm -rf hardhat/deployments/$NETWORK
  #clean hive dapp
}

# boot

function boot-message() {
  echo ""
  echo "############################################################################"
  echo "#" "$@"
  echo "############################################################################"
  echo ""
}

function deploy() {
  clean-deploy
  boot-message "Compiling contracts"
  compile-contracts
  boot-message "Deploying contracts"
  deploy-contracts
  boot-message "Funding services with tokens"
  fund-services-tokens
  boot-message "Printing balances"
  balances
}

function boot-hive() {
    if ! command -v bacalhau &>/dev/null; then
         echo "Error: bacalhau executable not found. trying to install bacalhau"
         curl -sL https://get.bacalhau.org/install.sh | sudo bash
    fi
    check_install

    sudo mkdir -p /app/coophive
    sudo chown -R $USER /app/coophive
    sudo ln -s $CONFIG_FILE /app/coophive/.env

    (
        set -euo pipefail
        cd ops/systemd
        sudo cp bacalhau.service /etc/systemd/system/
        sudo cp solver.service /etc/systemd/system/
        sudo cp mediator.service /etc/systemd/system/
        sudo cp job-creator.service /etc/systemd/system/
        sudo systemctl enable bacalhau
        sudo systemctl enable solver
        sudo systemctl enable job-creator
#        sudo systemctl enable mediator
    )

}

function boot() {
  boot-message "$0 clean : cleans previous setup"
  clean
  boot-message "$0 setup"
  setup
  boot-message "Starting geth"
  geth
  if [ ! -f "$CONFIG_FILE" ]; then
    boot-message "Genr env to $CONFIG_FILE"
    print-env > "$CONFIG_FILE"
  else
    echo "Configuration file $CONFIG_FILE found."
  fi
  source $CONFIG_FILE
  sleep 5
  boot-message "Funding admin account"
  fund-admin
  boot-message "Funding services with ether"
  fund-services-ether
  boot-message "$0 deploy : deploy contracts"
  deploy
  boot-message "$0 install"
  install
  boot-message "$0 integration-tests"
  integration-tests
  boot-message "$0 boot-hive"
  boot-hive
#  run cowsay:v0.1.2 -i Message="Hiro saves the bees"
}

eval "$@"


